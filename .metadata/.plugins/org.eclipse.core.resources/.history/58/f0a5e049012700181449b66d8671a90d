package algorithms;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeAlgos
{
	public void printTree(TreeNode root)
	{
		if (root == null)
			return;
		print(root, 0);
	}

	private void print(TreeNode root, int spaces)
	{
		if (root == null)
			return;

		print(root.right, spaces + 4);
		String blank = "";
		for (int i = 0; i < spaces; i++)
			blank += " ";
		System.out.println(blank + root.value);

		print(root.left, spaces + 4);
	}

	public TreeNode createBSTfromArray(int[] arr)
	{
		if (arr.length == 0)
			return null;
		if (arr.length == 1)
			return new TreeNode(arr[0]);

		return createBST(arr, 0, arr.length - 1);
	}

	private TreeNode createBST(int[] arr, int lo, int hi)
	{
		if (lo > hi)
			return null;

		int mid = ((lo + hi) / 2);
		TreeNode node = new TreeNode(arr[mid]);

		if (lo == hi)
			return node;

		node.left = createBST(arr, lo, mid - 1);
		node.right = createBST(arr, mid + 1, hi);

		return node;
	}

	public List<List<Integer>> levelOrder(TreeNode root)
	{
		List<List<Integer>> list = new ArrayList<List<Integer>>();
		if (root == null)
			return list;

		Queue<TreeNode> q = new LinkedList<TreeNode>();
		q.add(root);
		q.add(null);
		list.add(new ArrayList<Integer>());

		TreeNode prev = null;

		while (!q.isEmpty())
		{
			TreeNode node = q.remove();
			if (node == null)
			{
				if (prev == null)
					list.remove(list.size() - 1);
				else
				{
					q.add(null);
					list.add(new ArrayList<Integer>());
				}
			}
			else
			{
				list.get(list.size() - 1).add(node.value);
				if (node.left != null)
					q.add(node.left);
				if (node.right != null)
					q.add(node.right);
			}
			prev = node;
		}

		return list;

	}

	public int height(TreeNode root)
	{
		if (root == null)
			return 0;
		return 1 + Math.max(height(root.left), height(root.right));
	}

	public boolean isBalanced(TreeNode root)
	{
		// determine if the tree is height-balanced.
		if (root == null)
			return true;

		if (Math.abs(height(root.left) - height(root.right)) > 1)
			return false;

		return isBalanced(root.left) && isBalanced(root.right);

	}

	public boolean isValidBST(TreeNode root)
	{
		if (root == null)
			return true;

		return isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}

	public boolean isBST(TreeNode root, int min, int max)
	{
		if (root == null)
			return true;
		int i = root.value;
		if (i < min || i > max)
			return false;

		return (isBST(root.left, min, i - 1) && isBST(root.right, i + 1, max));
	}

	public TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q)
	{
		// Given a binary tree, find the lowest common ancestor (LCA) of two given nodes
		// in the tree.

		// Check if tree contains both p and q
		if (!treeContains(root, p) || !treeContains(root, q))
			return null;
		return findAncestor(root, p, q);

	}

	public TreeNode findAncestor(TreeNode root, TreeNode p, TreeNode q)
	{
		if (root == null)
			return null;

		if (root == p || root == q)
			return root;

		TreeNode leftRoot = findAncestor(root.left, p, q);
		TreeNode rightRoot = findAncestor(root.right, p, q);

		if (leftRoot != null && rightRoot != null)
			return root;

		return leftRoot != null ? leftRoot : rightRoot;
	}

	public boolean treeContains(TreeNode root, TreeNode x)
	{
		if (root == null)
			return false;
		if (root == x)
			return true;
		return (treeContains(root.left, x) || treeContains(root.right, x));
	}

	public boolean subTree(TreeNode t1, TreeNode t2)
	{
		// Check if binary tree t2 is subtree of binary tree t1

		if (t2 == null)
			return true;

		List<TreeNode> matchingNodes = new ArrayList<TreeNode>();
		findMatchingNodes(matchingNodes, t1, t2);
	}

	public List<TreeNode> findMatchingNodes(List<TreeNode> matchingNodes, TreeNode t1, TreeNode t2)
	{
		// returns list of nodes of t1 which match t2

		if (t1.value == t2.value)
			matchingNodes.add(t1);

	}
}
