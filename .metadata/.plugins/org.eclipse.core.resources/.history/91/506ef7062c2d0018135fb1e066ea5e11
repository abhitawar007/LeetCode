package algorithms;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public class ArraysAndStrings
{
	public List<List<String>> GroupAnagrams(String[] strs)
	{
		List<List<String>> list = new ArrayList<List<String>>();
		if (strs.length == 0)
			return list;

		HashMap<String, ArrayList<String>> map = new HashMap<>();

		for (String str : strs)
		{
			String sortedStr = sortString(str);

			if (!map.containsKey(sortedStr))
				map.put(sortedStr, new ArrayList<>());
			map.get(sortedStr).add(str);

		}
		for (String s : map.keySet())
			list.add(map.get(s));

		return list;
	}

	public String sortString(String str)
	{
		char[] chars = str.toCharArray();
		Arrays.sort(chars);
		return new String(chars);
	}

	public int lengthOfLongestSubstring(String s)
	{
		int len = s.length();
		if (len == 0 || len == 1)
			return len;

		List<Character> list = new ArrayList<>();
		int max = 0;

		for (int i = 0; i < len; i++)
		{
			if (list.contains(s.charAt(i)))
			{
				max = Math.max(max, list.size());
				while (list.get(0) != s.charAt(i))
					list.remove(0);
				list.remove(0);
			}
			list.add(s.charAt(i));
		}

		return Math.max(max, list.size());
	}

	public boolean increasingTriplet(int[] nums)
	{
		int len = nums.length;
		if (len < 3)
			return false;
		int min = Integer.MIN_VALUE;
		int a = min, b = min, c = min;

		for (int i = len - 1; i >= 0; i--)
		{
			if (nums[i] > c)
			{
				c = nums[i];
				b = min;
				a = min;
			}
			else if (nums[i] > b)
			{
				b = nums[i];
				a = min;
			}
			else if (nums[i] != c && nums[i] != b)
				return true;
		}
		return false;
	}

	public List<String> generateParanthesis(int n)
	{
		List<String> list = new ArrayList<>();
		if (n == 0)
			return list;

		int open = 1;

		String s = "{";
		int spaces = 2 * n - 1, maxLen = 2 * n;

		return generateParanthesis(list, s, open, spaces, maxLen);
	}

	public List<String> generateParanthesis(List<String> list, String s, int open, int spaces,
			int maxLen)
	{
		if (s.length() == maxLen)
		{
			list.add(s);
			return list;
		}

		if (open == spaces)
			list = generateParanthesis(list, s + "}", open - 1, spaces - 1, maxLen);
		else
		{
			list = generateParanthesis(list, s + "{", open + 1, spaces - 1, maxLen);
			if (open > 0)
				list = generateParanthesis(list, s + "}", open - 1, spaces - 1, maxLen);
		}
		return list;
	}

	public int removeElement(int[] arr, int val)
	{
		// 27. Remove Element. Return the new length. Don't care about order and what is
		// behind length
		int n = arr.length;
		if (n == 0)
			return n;

		int j = n - 1, i = 0;

		while (i <= j)
		{
			while (j >= 0 && arr[j] == val)
				j--;
			if (j == 0 || i >= j)
				return j + 1;
			if (arr[i] == val)
			{
				arr[i] = arr[j];
				arr[j] = val;
				j--;
			}
			i++;
		}
		return j + 1;

		//////////////////// or /////////////////
		// int id = 0, n = arr.length;
		// for(int i=0; i<n; i++)
		// {
		// if(arr[i] != val)
		// arr[id++] = arr[i];
		// }
		// return id;
	}

	public int findMinRot(int[] nums)
	{
		// 153. Find Minimum in Rotated Sorted Array

		if (nums.length == 0)
			return 0;

		int lo = 0, hi = nums.length - 1, mid = 0;

		while (lo < hi)
		{
			mid = (lo + hi) / 2;
			if (nums[mid] > nums[hi])
				lo = mid + 1;
			else
				hi = mid;
		}
		return nums[lo];
	}

	public int searchRot(int[] nums, int target)
	{
		// 33. Search in Rotated Sorted Array
		int n = nums.length;
		if (n == 0)
			return -1;

		int pivot = findMinRot(nums);
		int lo = 0, hi = nums.length - 1;

		while (lo <= hi)
		{
			int mid = lo + (hi - lo) / 2;
			int realmid = (lo + pivot) % n;
		}

	}
}
