package algorithms;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;

public class TreeAlgos
{

	private int ctr = 0;

	public void printTree(TreeNode root)
	{
		if (root == null)
			return;
		print(root, 0);
	}

	private void print(TreeNode root, int spaces)
	{
		if (root == null)
			return;

		print(root.right, spaces + 4);
		String blank = "";
		for (int i = 0; i < spaces; i++)
			blank += " ";
		System.out.println(blank + root.val);

		print(root.left, spaces + 4);
	}

	public TreeNode createBSTfromArray(int[] arr)
	{
		if (arr.length == 0)
			return null;
		if (arr.length == 1)
			return new TreeNode(arr[0]);

		return createBST(arr, 0, arr.length - 1);
	}

	private TreeNode createBST(int[] arr, int lo, int hi)
	{
		if (lo > hi)
			return null;

		int mid = ((lo + hi) / 2);
		TreeNode node = new TreeNode(arr[mid]);

		if (lo == hi)
			return node;

		node.left = createBST(arr, lo, mid - 1);
		node.right = createBST(arr, mid + 1, hi);

		return node;
	}

	public List<List<Integer>> levelOrder(TreeNode root)
	{
		List<List<Integer>> list = new ArrayList<List<Integer>>();
		if (root == null)
			return list;

		Queue<TreeNode> q = new LinkedList<TreeNode>();
		q.add(root);
		q.add(null);
		list.add(new ArrayList<Integer>());

		TreeNode prev = null;

		while (!q.isEmpty())
		{
			TreeNode node = q.remove();
			if (node == null)
			{
				if (prev == null)
					list.remove(list.size() - 1);
				else
				{
					q.add(null);
					list.add(new ArrayList<Integer>());
				}
			}
			else
			{
				list.get(list.size() - 1).add(node.val);
				if (node.left != null)
					q.add(node.left);
				if (node.right != null)
					q.add(node.right);
			}
			prev = node;
		}

		return list;

	}

	public int height(TreeNode root)
	{
		if (root == null)
			return 0;
		return 1 + Math.max(height(root.left), height(root.right));
	}

	public boolean isBalanced(TreeNode root)
	{
		// determine if the tree is height-balanced.
		if (root == null)
			return true;

		if (Math.abs(height(root.left) - height(root.right)) > 1)
			return false;

		return isBalanced(root.left) && isBalanced(root.right);

	}

	public boolean isValidBST(TreeNode root)
	{
		if (root == null)
			return true;

		return isBST(root, Integer.MIN_VALUE, Integer.MAX_VALUE);
	}

	public boolean isBST(TreeNode root, int min, int max)
	{
		if (root == null)
			return true;
		int i = root.val;
		if (i < min || i > max)
			return false;

		return (isBST(root.left, min, i - 1) && isBST(root.right, i + 1, max));
	}

	public TreeNode commonAncestor(TreeNode root, TreeNode p, TreeNode q)
	{
		// Given a binary tree, find the lowest common ancestor (LCA) of two given nodes
		// in the tree.

		// Check if tree contains both p and q
		if (!treeContains(root, p) || !treeContains(root, q))
			return null;
		return findAncestor(root, p, q);

	}

	public TreeNode findAncestor(TreeNode root, TreeNode p, TreeNode q)
	{
		if (root == null)
			return null;

		if (root == p || root == q)
			return root;

		TreeNode leftRoot = findAncestor(root.left, p, q);
		TreeNode rightRoot = findAncestor(root.right, p, q);

		if (leftRoot != null && rightRoot != null)
			return root;

		return leftRoot != null ? leftRoot : rightRoot;
	}

	public boolean treeContains(TreeNode root, TreeNode x)
	{
		if (root == null)
			return false;
		if (root == x)
			return true;
		return (treeContains(root.left, x) || treeContains(root.right, x));
	}

	public boolean isSubtree(TreeNode t1, TreeNode t2)
	{
		// 572. Subtree of Another Tree
		if (t2 == null)
			return true;

		if (traverse(t1, t2))
			return true;
		return false;
	}

	public boolean traverse(TreeNode t1, TreeNode t2)
	{
		if (t1 == null)
			return false;
		if (t1.val == t2.val)
			if (isBinarySubTree(t1, t2))
				return true;
		return traverse(t1.left, t2) || traverse(t1.right, t2);
	}

	public boolean isBinarySubTree(TreeNode t1, TreeNode t2)
	{
		if (t1 == null && t2 == null)
			return true;

		if (t1 == null && t2 != null)
			return false;

		if (t1 != null && t2 == null)
			return false;

		if (t1.val != t2.val)
			return false;

		return isBinarySubTree(t1.left, t2.left) && isBinarySubTree(t1.right, t2.right);
	}

	public boolean hasPathSum(TreeNode root, int sum)
	{
		// 112. Path Sum: Given a binary tree and a sum, determine if the tree has a
		// root-to-leaf path such that adding up all the values along the path equals
		// the given sum.
		if (root == null)
			return false;

		int subsum = sum - root.val;
		if (subsum == 0)
			if (root.left == null && root.right == null)
				return true;
		return hasPathSum(root.left, subsum) || hasPathSum(root.right, subsum);
	}

	public int pathSum(TreeNode root, int sum)
	{
		// 437. Path Sum III || also: CTCI
		printTree(root);

		if (root == null)
			return ctr;
		List<Integer> list = new ArrayList<>();
		list.add(sum);
		// list.add(sum-root.val);
		helperforPathSum(root, list, sum);
		return ctr;
	}

	public void helperforPathSum(TreeNode root, List<Integer> list, int sum)
	{
		if (root == null)
			return;
		for (int i : list)
			if (i == root.val)
				ctr++;
		List<Integer> temp = new ArrayList<>();
		temp.add(sum);
		for (int i : list)
		{
			int tempVal = i - root.val;
			// if (!list.contains(tempVal) && !temp.contains(tempVal))
			temp.add(i - root.val);
		}

//		if (list.size() > 1 && root.left == null && root.right == null && list.get(0) == root.val)
//			ctr++;

		// List<Integer> sendList = new ArrayList<>();

		// sendList.addAll(list);
		// sendList.addAll(temp);
		helperforPathSum(root.left, temp, sum);
		helperforPathSum(root.right, temp, sum);
	}

}
